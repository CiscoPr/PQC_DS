- Ter a certeza de que os docs do Falcon estão a fazer a análise da implementação otimizada ✅
- Ver as cenas que faltam da semana passada:
    - ver a documentação do Dilithium para perceber a relação entre as rejeições e o tempo:
        Sign(sk, M)
        05 z := ⊥
        06 while z = ⊥ do
        07     y ← S_{l,γ1-1}
        08     w1 := HighBits(Ay, 2γ2)
        09     c := H(M || w1)
        10     z := y + cs1
        11     if ||z||∞ ≥ γ1 - β or ||LowBits(Ay - cs2)||∞ ≥ γ2 - β then z := ⊥
    

    - entender o pq do Haraka ser o mais lento apesar de ser teoricamente o mais rápido para inputs pequenos: estou a usar flags de compilação -mavx2 -march=haswell
    que dão enable a uma aceleração de operações com inteiros e floating-point (via AVX2) que beneficiam o SHAKE e o SHA-2. A implementação mais diferenciada do HARAKA faz com que
    o mesmo não beneficie da mesma. Compilar de novo sem essas flags?

- Escrever na Tese sobre o Falcon
